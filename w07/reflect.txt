///////////////////////////////////////////////////////////////////////////
                               Reflection
                             Workshop - #7
Full Name  : Hyunjoo Han
Student ID#: 132749227

Authenticity Declaration:
I declare this submission is the result of my own work and has not been
shared with any other student or 3rd party content provider. This submitted
piece of work is entirely of my own creation.
///////////////////////////////////////////////////////////////////////////

1.Were you successful in coding non-repetitive sections of logic in the game play portion of this workshop (drawing of the ruler, board, player position, etc.)? If so, how did you accomplish this (don’t provide your code in your answer)? If not, why? Explain precisely what you struggled with and refer to the logic of the workshop to justify your answer.

For the <first ruler>, 
Since it needs to be determined based on the path length se by the user, I used a for-loop to print those three lines. The goal was to print a certain character for 'n'(which represents the path length) times. Printing the second and third lines of the ruler(the number part) was a tricky part for me, but I utilized the modulus operator(%10) to achieve the desired output. 
-2nd line(ruler) : When there is a remainder(not a multiple of 10), a '|' character should be printed. When there is no remainder(a multiple of 10), the corresponding number should be printed instead.
-3rd line(number) : When there is a remainder (not a multiple of 10), only the remainder (one-digit number) should be printed. For example, if the number is 14, the remainder would be 4, and only the digit 4 should be printed.(1%1=1, 1%2=2, ....., 10%10=0, 11%10=1...)

For the <Second ruler - while playing the game>,
-1st line(player position) : I used the user's input, which represents the next move. Using a for-loop, I printed 0 or more empty space(' ') accordingly and the player's symbol.
-2nd line(board) : I used array to print the symbols in the program. Three arrays were used: history, bomb, treasure. The array for bomb and treasure were already initialized by user input, while the array of history was not. To initialize the array of history, I implemented code that sets the value to 1 when the user inputs a valid next move. After that, I checked the values of the arrays(history, bomb, and treasure) to determine the appropriate symbol to print. The program examined if the value in each array was 0 or 1. Based on these conditions, the corresponding symbol was printed accordingly.
In addition, printing the symbols was not a straightforward task, as I needed to print symbols for all the visited places. The array was instrumental in accomplishing this, as it stored all the necessary records and provided a means to access and print the symbols for each move.

2.Explain how the use of structures simplified your program. Provide proof of your argument by contrasting the alternatives – do not include code in your answer – you must explain in simple terms the impact the concept of structures has in our programming strategies.

The 'PlayerInfo' structure represents the player and includes attributes such as the number of lives, the player's name, the number of treasures found, and a history of the player's mo es. By grouping these attributes together in a structure, it became easier to manage and access the player's information throughout the program. Instead of using separate variables for each player attribute, they are encapsulated within the 'PlayerInfo'
The 'GameInfo' is similar. The structure stores information about game, including the number of moves allowed, the length of the game path, an array for bomb placement, and an array for treasure placement. By organizing these attributes within a structure, the code becomes more organized and easier to understand.
Overall, the structure make it easy to organize, reuse the code, and manage the datas.


3. Examine your code and determine the maximum number of levels of nesting (deepest) you ended up using in your program logic. Provide a simple indented outline that illustrates your answer (copy only the construct line for each level and do not include all the code within unless there is another nested construct).

while (player.lives != 0 && game.moves != 0)
{
 for (i = 0; i < game.pathLength; i++)
        {
            if (player.history[i] != 1)
            {
            }
            else if (player.history[i] == 1)
            {
                if (game.bombs[i] != 1 && game.treasures[i] != 1)
                {
                }
                else if (game.bombs[i] == 1 && game.treasures[i] != 1)
                {
                }
                else if (game.bombs[i] != 1 && game.treasures[i] == 1)
                {
                }
                else if (game.bombs[i] == 1 && game.treasures[i] == 1)
                {
                }
            }
        }
}

while : check if there is more 'lives' or 'moves'
  for : iterate it for 'n'(path length)times.
    if-else if :  check history.
      if-else ifs :check bombs and treasures.
