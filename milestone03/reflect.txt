///////////////////////////////////////////////////////////////////////////
                               Reflection
                               Milestone*
Full Name  : Hyunjoo Han
Student ID#: 132749227

Authenticity Declaration:
I declare this submission is the result of my own work and has not been
shared with any other student or 3rd party content provider. This submitted
piece of work is entirely of my own creation.
///////////////////////////////////////////////////////////////////////////

1. 
In this Milestone, I create 3 functions.
Which are, [ InputDate / TimeForAppointment / sortAppointment ]
void InputDate(struct Date* inputDate);
==>> This function doesn't return anything, but it takes input from the users, tests all the conditions it needs to be tested, and stores it in the struct that is passed by pointer. Among the three functions that I created, this one was the most useful. I utilized it for 'viewAppointmentSchedule', 'addAppointment', and 'removeAppointment'. Without using it three times, It would have required me to replicate a significant amount of identical code across the functions. However, through the utilization of this function, I was able to eliminate repetition and enhance the readability of the code.
void TimeForAppointment(struct Time* appointmentTime);
==>> This function resembles 'InputDate'. Although it doesn't yield any return value, it collects user input, tests all necessary conditions, and stores the inputs in the struct that is passed by pointer. I developed this function to circumvent the need for composing extensive blocks of code. In addition to the standard range conditions (0-24 for hours, 0-60 for minutes), I had to account for additional constraints: the input had to fall within the opening and closing hours, with intervals of 30 minutes. Given these considerations, the creation of a dedicated function for this purpose seemed logical.
void SortAppointments(struct Appointment appoints[], int max);
==>> This function accepts a struct array and arranges the data in ascending order by comparing the year, month, day, hour, and minute values. To achieve this, I establish multiple conditions that determine whether a data item should be swapped with another. I used this function within 'importAppointments' to pre-sort the data before its utilization in various functions, such as 'viewAllAppointments'. However, I found it necessary to reuse this function for the 'addAppointment' operation, as newly added data may not be in the correct order initially.

2.
I utilized the 'scanf' function on a single occasion. I refrained from using it multiple times by capitalizing on the functions I constructed within 'core.c,' as well as the supplementary functions I created for milestone-3. These functions serve to validate the input before it is stored in the variable, ensuring the conformity of the value to the anticipated format. This approach obviates the need for repeated validation every time input is acquired from the user. Additionally, in cases where user input fails to meet validation criteria, an associated error message is displayed.

3.
void InputDate(struct Date* inputDate);
-As I previously mentioned, I placed it into 'viewAppointmentSchedule,' 'addAppointment,' and 'removeAppointment.' The decision to create this function was driven by the presence of an excessive number of conditions that needed to be checked for input validation.
void TimeForAppointment(struct Time* appointmentTime);
-I placed this function within 'addAppointments.' The reason behind creating this function is rooted in its requirement to handle specific conditions for input validation. Moreover, without the utilization of this function, the code could have become excessively lengthy in order to achieve the same objective.
void SortAppointments(struct Appointment appoints[], int max);
-I placed this function into both 'importAppointment' and 'addAppointment,' aiming to enhance the clarity and manageability of each respective function. By avoiding the repetition of writing the same code multiple times, I am able to maintain a cleaner and more organized code. 
In conclusion, the reason why creating functions and placing them appropriately within the modules has significantly contributed to the improvement of the overall code structure and readability.

